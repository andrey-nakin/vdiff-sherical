//#!/usr/bin/scilab -nwni -nb -f

//# Загружаем модуль решения обыкновеных дифф. уравнений (ОДУ)
//pkg load odepkg;

//###############################################################################
//
// Тестовая программа для решения задачи о миграции и поглощении вакансий
// Версия 4.2
//
//###############################################################################

//###############################################################################
//
// Параметры вычислений
//
//###############################################################################

// Количество слоёв в системе
N = 100;

// Количество временных шагов в результирующих данных
global M
M = 60000;

// Толщина одного слоя, м
dr = 5e-9;

// Максимальное время интегрирования, с
global tmax
tmax = 6000;

// Радиус дислокации, м
R = 5e-9;

// Параметр альфа из формулы (35)
alpha = 7.5e-5;

// Температура нагрева, К
T_heat = 600;

// Температура охлаждения, К
T_freeze = 300;

// Время нагревания в пределах одного термоцикла, сек
t_heat = 500;

// Время охлаждения в пределах одного термоцикла, сек
t_freeze = 100;

// Характерное время нагревания, сек
t_c_heat = 50;

// Характерное время охлаждения, сек
global t_c_freeze
t_c_freeze = 1;

// Функция вычисляет температуру в слое i в момент времени t
// Температура в К, время в сек.
// Считаем, что температура одинакова во всей системе
function res = T(i, t)
	global T_heat T_freeze t_heat t_freeze t_c_heat t_c_freeze

	// Продолжительность одного термоцикла
	tc = t_freeze + t_heat;
	// Время в пределах текущего термоцикла
	ti = t - floor(t / tc) * tc;

	if (ti < t_freeze)
		// охлаждение
		res = T_freeze + (T_heat - T_freeze) * exp(-ti / t_c_freeze);
	else
		// нагревание
		res = T_heat + (T_freeze - T_heat) * exp(-(ti - t_freeze) / t_c_heat);
	end
endfunction

// Функция вычисляет производную температуры по времени
// в слое i в момент времени t
// Температура в К, время в сек.
// Считаем, что температура одинакова во всей системе
function res = dT(i, t)
	global T_heat T_freeze t_heat t_freeze t_c_heat t_c_freeze

	// Продолжительность одного термоцикла
	tc = t_freeze + t_heat;
	// Время в пределах текущего термоцикла
	ti = t - floor(t / tc) * tc;

	if (ti < t_freeze)
		// охлаждение
		res = (T_freeze - T_heat) * exp(-ti / t_c_freeze) / t_c_freeze;
	else
		// нагревание
		res = (T_heat - T_freeze) * exp(-(ti - t_freeze) / t_c_heat) / t_c_heat;
	end
endfunction

// Функция вычисляет давление в слое i в момент времени t
// Давление в Па, время в сек.
function res = P(i, t)
	// Считаем, что давление одинаково и равно нулю во всей системе
	res = 0;
endfunction

//###############################################################################
//
// Константы
//
//###############################################################################

// Постоянная Больцмана, Дж/К
k = 1.38e-23;

// Толщина одного атомного слоя, м
l = 3e-10;

// Средний объём атома, куб. м
v = l * l * l;

// Энергия формирования вакансий, Дж
U_f = 1.0 * 1.6e-19;

// Энергия миграции вакансий, Дж
U_m = 0.5 * 1.6e-19;

// Размерный коэффициент в формуле (3), 1/куб.м
C_0 = 1 / v;

// Размерный коэффициент в формуле (4), кв.м/с
D_0 = 1.0e-7;

// Толщина дислокации, м
b = l;

// Частота Дебая, 1/с
nu = 1.0e16;

// Вероятность перескока вакансий в дислокацию
p = 1.0e-2;

// Число пи
pi = 3.14159265;

//###############################################################################
//
// Основные формулы
//
//###############################################################################

// Равновесная концентрация вакансий при температуре T и давлении P
// Формула (2)
function res = eqC(T, P)
	global C_0 U_f v k
	res = C_0 * exp(-(U_f + P * v) / (k * T));
endfunction

// Коэффициент диффузии вакансий в зависимости от температуры T
// Формула (3)
function res = D(T)
	global D_0 U_m k
	res = D_0 * exp(-U_m / (k * T));
endfunction

// Хим. потенциал при заданной концентрации вакансий C, температуре T, и давлении P
// Формула (4)
function res = mu(C, T, P)
	global k
	res = k * T * log(C / eqC(T, P));
endfunction

// Формула поглощения вакансий дислокацией радиуса R в слое с хим. потенциалом mu
// Формула (13)
function res = adsorb(R, mu)
	global b nu p v pi
	res = -2 * pi * R * b * b * nu * p * mu / v;
	if (res > 0)
		// петля не может испускать вакансии
		res = 0
	end
endfunction

//###############################################################################
//
// Вспомогательные функции
//
//###############################################################################

// Вычисляет объём i-го слоя
function res = layerV(i)
	global dr
	res = 4 / 3 * pi * dr * dr * dr * (3 * i * i - 3 * i + 1);
endfunction

// Переводит величину g в размерную концентрацию, ce - равновесная концентрация
function res = gamma2C(g, ce)
	// формула (7)
	res = ce * exp(g);
endfunction

// Вычисляет полное число вакансий в системе g в момент времени t
function res = numVac(g, t)
	global N

	res = 0;

	for i = 1:N
	  ce = eqC(T(i, t), P(i, t));
	  res = res + gamma2C(g(i), ce) * layerV(i);
	end
endfunction

function readCommandLineArgs()
	global tmax t_c_freeze M
	
	args = sciargs();
	n = size(args);
	for i = 2 : n(2)
		if args(i) == "-t_c_freeze" 
			t_c_freeze = strtod(args(i+1));
		end
		if args(i) == "-tmax" 
			tmax = strtod(args(i+1));
		end
		if args(i) == "-M" 
			M = strtod(args(i+1));
		end
	end
endfunction

//##############################################################################
//
// Основная функция системы ОДУ
//
//###############################################################################

function res = calcGamma(t, g)
	global N dr k R U_f v alpha

	res = zeros(N, 1);

	// Вычисляем потоки вакансий, формула (31)
	j_in = zeros(N, 1);
	j_out = zeros(N, 1);
	for i = 1:N-1
		T_i = T(i, t);	// температура в данном слое
		T_next = T(i + 1, t);	// температура в следующем слое
		P_i = P(i, t);	// давление в данном слое
		P_next = P(i + 1, t);	// давление в следующем слое
		mu_i = k * T_i * g(i);	// хим. потенциал в данном слое
		mu_next = k * T_next * g(i + 1);	// хим. потенциал в след. слое
		C_e_i = eqC(T_i, P_i);	// равновесная концентрация в данном слое
		C_e_next = eqC(T_next, P_next);	// равновесная концентрация в след. слое

		j_out(i) = (D(T_next) + D(T_i)) / (2 * k) * (C_e_next + C_e_i) / (T_next + T_i) * (mu_i - mu_next) / dr * exp(0.5 * (g(i+1) + g(i)));
	end

	// Уравнения (33)
	j_in(2:N) = j_out(1:N-1);
	// Уравнение (36)
	j_out(N) = D(T_next) / k * C_e_next / T_next * (alpha * mu_next) / dr * exp(g(N));
	
	// Вычисляем приращения концентраций, формула (27)
	flux = zeros(N, 1);
	ts = zeros(N, 1);
	for i = 1:N
		i2 = i * i;
		T_i = T(i, t);
		P_i = P(i, t);

		if ( i == 1 )	// поглощение вакансий только в первом слое
			dn = 1 / (4 * pi * dr * dr) * adsorb(R, k * T_i * g(i));
		else
			dn = 0;
		end
		
		flux(i) = ( (i - 1) * (i - 1) * j_in(i) - i2 * j_out(i) + dn ) / ( dr * (i2 - i + 1 / 3) * eqC(T_i, P_i) * exp(g(i)) );

		ts(i) = (U_f + P_i * v) / (k * T_i * T_i) * dT(i, t);

		res(i) = flux(i) - ts(i);
	end
endfunction

//###############################################################################
//
// Решаем систему ОДУ
//
//###############################################################################

// Считываем параметры из командной строки
readCommandLineArgs();

// Создаём систему слоёв с начальными значениями концентраций, формула (37)
g = zeros(N, 1);
numVac0 = numVac(g, 0);

// Решаем систему ОДУ
times = 0:tmax/M:tmax;
//%ODEOPTIONS=[1,0,0,%inf,0,2,50000,12,5,0,-1,-1];
[result] = ode("adams", g, 0, times, calcGamma);
sz = size(result);
m = sz(2)-1;

// Вычисляем число поглощённых вакансий, формула (38)
inner = result(1, :)';
n_ads = 0;
for i = 1:m
	T_1 = T(1, times(i));
	n_ads = n_ads - (times(i + 1) - times(i)) * adsorb(R, k * T_1 * inner(i));
end
printf("START\t%d\nEND\t%g\nn_ads\t%g\n", numVac(result(:, 1)', 0), numVac(result(:, m+1)', tmax), n_ads);

// Выводим результаты в файлы
g_1 = zeros(m + 1, 2);
g_N = zeros(m + 1, 2);
TT = zeros(m + 1, 2);
for i = 1 : m + 1
	g_1(i, 1) = times(i);
	g_1(i, 2) = result(1, i);

	g_N(i, 1) = times(i);
	g_N(i, 2) = result(N, i);

	TT(i, 1) = times(i);
	TT(i, 2) = T(1, times(i));
end
fprintfMat("g_1.txt", g_1);
fprintfMat("g_N.txt", g_N);
fprintfMat("T.txt", TT);

exit

